{
  "tasks": [
    {
      "id": 1,
      "title": "Install Node.js and Required Tools",
      "description": "Set up the development environment by installing Node.js and the schema-to-OpenAPI tool (@platformatic/sql-openapi).",
      "details": "1. Download Windows LTS from https://nodejs.org and install\n2. Open command prompt or PowerShell\n3. Run `npm install -g @platformatic/sql-openapi` to install the schema-to-OpenAPI tool globally\n4. Verify installation with `node --version` and `sql-openapi --version`",
      "testStrategy": "Verify successful installation by running version check commands. Ensure Node.js is properly installed and the sql-openapi tool is accessible from the command line.",
      "priority": "high",
      "dependencies": [],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 2,
      "title": "Generate Initial OpenAPI Specification",
      "description": "Generate the initial OpenAPI specification from the MySQL database schema using the sql-openapi tool.",
      "details": "1. Connect to the local MySQL database\n2. Run the command:\n```bash\nsql-openapi generate \\\n  --database mysql://root@localhost/duv_local \\\n  --output duv-openapi.yaml\n```\n3. Verify the generated YAML file contains all database tables and relationships",
      "testStrategy": "Validate the generated YAML file against the OpenAPI 3.0 specification. Ensure all database tables are properly represented in the generated specification.",
      "priority": "high",
      "dependencies": [
        1
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 3,
      "title": "Refine OpenAPI Specification",
      "description": "Refine the generated OpenAPI specification to create duv-api-public.yaml by removing private tables/fields and standardizing field names.",
      "details": "1. Create a copy of duv-openapi.yaml named duv-api-public.yaml\n2. Remove all private tables and sensitive fields\n3. Rename columns to follow consistent naming conventions (e.g., Startdate → date)\n4. Set appropriate JSON types and formats for each field\n5. Add descriptions for each endpoint and parameter\n6. Ensure all four core endpoints are properly defined:\n   - /api/v1/events.php\n   - /api/v1/eventdetail.php\n   - /api/v1/performances.php\n   - /api/v1/runners.php",
      "testStrategy": "Validate the refined YAML against OpenAPI 3.0 specification. Review manually to ensure all private data has been removed and naming conventions are consistent.",
      "priority": "high",
      "dependencies": [
        2
      ],
      "status": "done",
      "subtasks": []
    },
    {
      "id": 4,
      "title": "Set Up Swagger UI Locally",
      "description": "Download and configure Swagger UI to provide interactive documentation for the API.",
      "details": "1. Download Swagger UI ZIP from https://github.com/swagger-api/swagger-ui/releases\n2. Unzip to a directory named 'duv-docs/'\n3. Edit duv-docs/index.html to set url: 'duv-api-public.yaml'\n4. Open the index.html file in a browser to verify the documentation displays correctly\n5. Test the interactive features to ensure they work as expected",
      "testStrategy": "Open the Swagger UI in multiple browsers to verify compatibility. Test the interactive documentation features to ensure they correctly display API endpoints, parameters, and response schemas.",
      "priority": "medium",
      "dependencies": [
        3
      ],
      "status": "in-progress",
      "subtasks": []
    },
    {
      "id": 5,
      "title": "Publish Documentation via GitHub Pages",
      "description": "Create a GitHub repository and publish the Swagger UI documentation using GitHub Pages.",
      "details": "1. Create a new GitHub repository named 'duv-api-docs'\n2. Push the duv-docs/ directory and duv-api-public.yaml file to the repository\n3. In the repository settings, enable GitHub Pages:\n   - Select branch: main\n   - Select folder: / (root)\n4. Wait for GitHub Pages to build and deploy the site\n5. Note the published URL for inclusion in the email to Jürgen",
      "testStrategy": "Verify the GitHub Pages site is accessible and displays the Swagger UI correctly. Test all interactive features to ensure they work in the published environment.",
      "priority": "medium",
      "dependencies": [
        4
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 6,
      "title": "Create SQL Script for api_keys Table",
      "description": "Prepare the SQL script to create the api_keys table for API authentication.",
      "details": "Create a SQL script file named 'create_api_keys_table.sql' with the following content:\n```sql\nCREATE TABLE api_keys (\n  `key` VARCHAR(64) PRIMARY KEY,\n  user_id INT NOT NULL,\n  expires DATETIME,\n  active BOOL DEFAULT TRUE\n);\n```\nInclude any necessary indexes or foreign key constraints to link with the existing user table.",
      "testStrategy": "Validate the SQL script syntax. Test the script in a development database to ensure it creates the table with the correct structure and constraints.",
      "priority": "high",
      "dependencies": [],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 7,
      "title": "Develop API Helper Functions",
      "description": "Create a PHP helper file with common functions for database connection, API key validation, and JSON output.",
      "details": "Create a file named 'helpers.php' in the /api/v1/ directory with the following functions:\n```php\n<?php\nfunction connectToDatabase() {\n  return new mysqli('localhost','user','pass','duv');\n}\n\nfunction validateApiKey($db, $required = true) {\n  $key = $_SERVER['HTTP_X_API_KEY'] ?? '';\n  if (!$key && !$required) return true;\n\n  $stmt = $db->prepare(\n    'SELECT user_id FROM api_keys WHERE `key`=? AND active=1'\n  );\n  $stmt->bind_param('s', $key);\n  $stmt->execute();\n  if ($stmt->get_result()->num_rows === 0) {\n    if ($required) {\n      http_response_code(401);\n      echo json_encode(['error'=>'Invalid API key']);\n      exit;\n    }\n    return false;\n  }\n  return $stmt->get_result()->fetch_assoc()['user_id'];\n}\n\nfunction outputJson($data) {\n  header('Content-Type: application/json');\n  echo json_encode($data);\n  exit;\n}\n```\nUpdate database credentials as needed for the specific environment.",
      "testStrategy": "Test each function individually with unit tests. Verify database connection works, API key validation correctly handles valid and invalid keys, and JSON output properly formats and returns data.",
      "priority": "high",
      "dependencies": [
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 8,
      "title": "Implement events.php Endpoint",
      "description": "Create the /api/v1/events.php endpoint to provide a list of events with standardized field names.",
      "details": "Create a file named 'events.php' in the /api/v1/ directory with the following content:\n```php\n<?php\nrequire 'helpers.php';\n$db = connectToDatabase();\nvalidateApiKey($db, false); // public access\n\n// Optional: read filter params\n$year = $_GET['year'] ?? date('Y');\n\n$query = \"SELECT\n  ID AS id,\n  EventName AS name,\n  CountryCode AS country,\n  DATE_FORMAT(Startdate,'%Y-%m-%d') AS date,\n  Distance AS distance_km\nFROM tevent\nWHERE YEAR(Startdate)=?\";\n$stmt = $db->prepare($query);\n$stmt->bind_param('i', $year);\n$stmt->execute();\n$result = $stmt->get_result();\n\n$events = [];\nwhile ($row = $result->fetch_assoc()) {\n  $events[] = $row;\n}\n\noutputJson($events);\n```\nEnsure field names match those defined in the OpenAPI specification.",
      "testStrategy": "Test the endpoint with various query parameters. Verify the response format matches the OpenAPI specification. Test with and without API keys to ensure public access works correctly.",
      "priority": "medium",
      "dependencies": [
        3,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 9,
      "title": "Implement eventdetail.php Endpoint",
      "description": "Create the /api/v1/eventdetail.php endpoint to provide detailed information about a specific event.",
      "details": "Create a file named 'eventdetail.php' in the /api/v1/ directory:\n```php\n<?php\nrequire 'helpers.php';\n$db = connectToDatabase();\nvalidateApiKey($db, false); // public access\n\n// Required parameter\n$eventId = $_GET['id'] ?? null;\nif (!$eventId) {\n  http_response_code(400);\n  outputJson(['error' => 'Event ID is required']);\n}\n\n$query = \"SELECT\n  ID AS id,\n  EventName AS name,\n  CountryCode AS country,\n  DATE_FORMAT(Startdate,'%Y-%m-%d') AS date,\n  Distance AS distance_km,\n  City AS city,\n  Website AS website_url\nFROM tevent\nWHERE ID=?\";\n$stmt = $db->prepare($query);\n$stmt->bind_param('i', $eventId);\n$stmt->execute();\n$result = $stmt->get_result();\n\nif ($result->num_rows === 0) {\n  http_response_code(404);\n  outputJson(['error' => 'Event not found']);\n}\n\noutputJson($result->fetch_assoc());\n```\nEnsure field names match those defined in the OpenAPI specification.",
      "testStrategy": "Test the endpoint with valid and invalid event IDs. Verify error handling for missing parameters and non-existent events. Confirm the response format matches the OpenAPI specification.",
      "priority": "medium",
      "dependencies": [
        3,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 10,
      "title": "Implement performances.php Endpoint",
      "description": "Create the /api/v1/performances.php endpoint to provide performance results for a specific event.",
      "details": "Create a file named 'performances.php' in the /api/v1/ directory:\n```php\n<?php\nrequire 'helpers.php';\n$db = connectToDatabase();\n$hasApiKey = validateApiKey($db, false); // optional auth for restricted fields\n\n// Required parameter\n$eventId = $_GET['event_id'] ?? null;\nif (!$eventId) {\n  http_response_code(400);\n  outputJson(['error' => 'Event ID is required']);\n}\n\n$query = \"SELECT\n  p.ID AS id,\n  p.RunnerID AS runner_id,\n  CONCAT(r.FirstName, ' ', r.LastName) AS runner_name,\n  r.CountryCode AS country,\n  p.Place AS place,\n  p.Time AS time_seconds,\n  CONCAT(FLOOR(p.Time/3600), ':', LPAD(FLOOR((p.Time%3600)/60), 2, '0'), ':', LPAD(p.Time%60, 2, '0')) AS time_formatted\";\n  \n// Add restricted fields if API key is provided\nif ($hasApiKey) {\n  $query .= \",\n  r.Email AS email,\n  r.DateOfBirth AS date_of_birth\";\n}\n\n$query .= \"\nFROM tperformance p\nJOIN trunner r ON p.RunnerID = r.ID\nWHERE p.EventID=?\nORDER BY p.Place\";\n\n$stmt = $db->prepare($query);\n$stmt->bind_param('i', $eventId);\n$stmt->execute();\n$result = $stmt->get_result();\n\n$performances = [];\nwhile ($row = $result->fetch_assoc()) {\n  $performances[] = $row;\n}\n\noutputJson($performances);\n```\nEnsure field names match those defined in the OpenAPI specification.",
      "testStrategy": "Test the endpoint with valid and invalid event IDs. Test with and without API keys to verify restricted fields are only included with valid authentication. Verify the response format matches the OpenAPI specification.",
      "priority": "medium",
      "dependencies": [
        3,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 11,
      "title": "Implement runners.php Endpoint",
      "description": "Create the /api/v1/runners.php endpoint to provide runner profile information.",
      "details": "Create a file named 'runners.php' in the /api/v1/ directory:\n```php\n<?php\nrequire 'helpers.php';\n$db = connectToDatabase();\n$hasApiKey = validateApiKey($db, false); // optional auth for restricted fields\n\n// Required parameter\n$runnerId = $_GET['id'] ?? null;\nif (!$runnerId) {\n  http_response_code(400);\n  outputJson(['error' => 'Runner ID is required']);\n}\n\n$query = \"SELECT\n  ID AS id,\n  FirstName AS first_name,\n  LastName AS last_name,\n  CountryCode AS country\";\n  \n// Add restricted fields if API key is provided\nif ($hasApiKey) {\n  $query .= \",\n  Email AS email,\n  DateOfBirth AS date_of_birth,\n  Gender AS gender\";\n}\n\n$query .= \"\nFROM trunner\nWHERE ID=?\";\n\n$stmt = $db->prepare($query);\n$stmt->bind_param('i', $runnerId);\n$stmt->execute();\n$result = $stmt->get_result();\n\nif ($result->num_rows === 0) {\n  http_response_code(404);\n  outputJson(['error' => 'Runner not found']);\n}\n\n$runner = $result->fetch_assoc();\n\n// Get runner's performances\n$perfQuery = \"SELECT\n  p.ID AS id,\n  e.EventName AS event_name,\n  e.ID AS event_id,\n  DATE_FORMAT(e.Startdate,'%Y-%m-%d') AS event_date,\n  p.Place AS place,\n  CONCAT(FLOOR(p.Time/3600), ':', LPAD(FLOOR((p.Time%3600)/60), 2, '0'), ':', LPAD(p.Time%60, 2, '0')) AS time_formatted\nFROM tperformance p\nJOIN tevent e ON p.EventID = e.ID\nWHERE p.RunnerID=?\nORDER BY e.Startdate DESC\";\n\n$perfStmt = $db->prepare($perfQuery);\n$perfStmt->bind_param('i', $runnerId);\n$perfStmt->execute();\n$perfResult = $perfStmt->get_result();\n\n$performances = [];\nwhile ($row = $perfResult->fetch_assoc()) {\n  $performances[] = $row;\n}\n\n$runner['performances'] = $performances;\n\noutputJson($runner);\n```\nEnsure field names match those defined in the OpenAPI specification.",
      "testStrategy": "Test the endpoint with valid and invalid runner IDs. Test with and without API keys to verify restricted fields are only included with valid authentication. Verify the response format matches the OpenAPI specification and includes the runner's performances.",
      "priority": "medium",
      "dependencies": [
        3,
        7
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 12,
      "title": "Create Admin UI for API Keys",
      "description": "Develop a simple PHP admin page for generating and managing API keys.",
      "details": "Create a file named 'api_keys.php' in the admin/ directory:\n```php\n<?php\n// Require admin authentication\nsession_start();\nif (!isset($_SESSION['admin_id'])) {\n  header('Location: login.php');\n  exit;\n}\n\n$db = new mysqli('localhost','user','pass','duv');\n\n// Handle form submission to generate new key\nif ($_SERVER['REQUEST_METHOD'] === 'POST') {\n  $userId = $_POST['user_id'] ?? null;\n  $expires = $_POST['expires'] ?? null;\n  \n  if ($userId) {\n    // Generate random API key\n    $key = bin2hex(random_bytes(32));\n    \n    $stmt = $db->prepare('INSERT INTO api_keys (`key`, user_id, expires, active) VALUES (?, ?, ?, 1)');\n    $stmt->bind_param('sis', $key, $userId, $expires);\n    $stmt->execute();\n    \n    $message = \"New API key generated: $key\";\n  }\n}\n\n// Get all active API keys\n$keys = [];\n$result = $db->query('SELECT k.`key`, k.user_id, CONCAT(u.FirstName, \" \", u.LastName) AS user_name, k.expires FROM api_keys k JOIN trunner u ON k.user_id = u.ID WHERE k.active = 1');\nwhile ($row = $result->fetch_assoc()) {\n  $keys[] = $row;\n}\n\n// Get all users for dropdown\n$users = [];\n$result = $db->query('SELECT ID, CONCAT(FirstName, \" \", LastName) AS name FROM trunner ORDER BY LastName, FirstName');\nwhile ($row = $result->fetch_assoc()) {\n  $users[] = $row;\n}\n?>\n<!DOCTYPE html>\n<html>\n<head>\n  <title>API Key Management</title>\n  <style>\n    body { font-family: Arial, sans-serif; margin: 20px; }\n    table { border-collapse: collapse; width: 100%; }\n    th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }\n    th { background-color: #f2f2f2; }\n    .message { background-color: #d4edda; color: #155724; padding: 10px; margin-bottom: 20px; }\n    form { margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border: 1px solid #ddd; }\n  </style>\n</head>\n<body>\n  <h1>API Key Management</h1>\n  \n  <?php if (isset($message)): ?>\n  <div class=\"message\"><?php echo $message; ?></div>\n  <?php endif; ?>\n  \n  <form method=\"post\">\n    <h2>Generate New API Key</h2>\n    <div>\n      <label for=\"user_id\">User:</label>\n      <select name=\"user_id\" required>\n        <option value=\"\">Select User</option>\n        <?php foreach ($users as $user): ?>\n        <option value=\"<?php echo $user['ID']; ?>\"><?php echo htmlspecialchars($user['name']); ?></option>\n        <?php endforeach; ?>\n      </select>\n    </div>\n    <div>\n      <label for=\"expires\">Expires (optional):</label>\n      <input type=\"date\" name=\"expires\">\n    </div>\n    <button type=\"submit\">Generate Key</button>\n  </form>\n  \n  <h2>Active API Keys</h2>\n  <table>\n    <thead>\n      <tr>\n        <th>Key</th>\n        <th>User</th>\n        <th>Expires</th>\n        <th>Actions</th>\n      </tr>\n    </thead>\n    <tbody>\n      <?php foreach ($keys as $key): ?>\n      <tr>\n        <td><?php echo $key['key']; ?></td>\n        <td><?php echo htmlspecialchars($key['user_name']); ?> (ID: <?php echo $key['user_id']; ?>)</td>\n        <td><?php echo $key['expires'] ? $key['expires'] : 'Never'; ?></td>\n        <td><a href=\"revoke_key.php?key=<?php echo urlencode($key['key']); ?>\" onclick=\"return confirm('Are you sure?')\">Revoke</a></td>\n      </tr>\n      <?php endforeach; ?>\n    </tbody>\n  </table>\n</body>\n</html>\n```\n\nAlso create a simple 'revoke_key.php' script to deactivate keys:\n```php\n<?php\nsession_start();\nif (!isset($_SESSION['admin_id'])) {\n  header('Location: login.php');\n  exit;\n}\n\n$key = $_GET['key'] ?? '';\nif ($key) {\n  $db = new mysqli('localhost','user','pass','duv');\n  $stmt = $db->prepare('UPDATE api_keys SET active = 0 WHERE `key` = ?');\n  $stmt->bind_param('s', $key);\n  $stmt->execute();\n}\n\nheader('Location: api_keys.php');\n```",
      "testStrategy": "Test the admin UI by generating new API keys for different users. Verify keys are correctly stored in the database. Test the revocation functionality to ensure keys can be deactivated. Verify the UI correctly displays all active keys.",
      "priority": "medium",
      "dependencies": [
        6
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 13,
      "title": "Write Email to Jürgen",
      "description": "Compose an email to Jürgen explaining the API migration proposal and outlining next steps.",
      "details": "Compose an email with the following structure:\n\nSubject: \"DUV API v1 Migration Proposal\"\n\nBody:\n```\nHi Jürgen,\n\nI've completed the initial work on the DUV API v1 migration as we discussed. This new API will provide standardized JSON responses, interactive documentation, and improved security through API keys.\n\nKey benefits:\n- Consistent field names and data formats across all endpoints\n- Self-documenting API with interactive Swagger UI\n- API key authentication for protected data\n- Gradual migration path that won't disrupt the current site\n\nYou can view the API documentation here: [GitHub Pages URL]\n\nI've attached the OpenAPI specification file (duv-api-public.yaml) which defines all endpoints and data structures.\n\nNext steps for implementation:\n1. Create the api_keys table in the database (SQL script attached)\n2. Implement the API helper functions and endpoints as outlined in the PRD\n3. Create the admin UI for managing API keys\n4. Update frontend code to use the new endpoints\n\nLet me know if you have any questions or need any clarification on the implementation details.\n\nBest regards,\nDaniel\n```\n\nAttach:\n1. duv-api-public.yaml\n2. create_api_keys_table.sql",
      "testStrategy": "Review the email for clarity and completeness. Ensure all attachments are included and the GitHub Pages URL is correct.",
      "priority": "low",
      "dependencies": [
        5
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 14,
      "title": "Update Frontend Fetch Calls",
      "description": "Modify frontend JavaScript code to use the new API endpoints and include API key headers.",
      "details": "For each JavaScript file that makes API calls to the old /json/*.php endpoints:\n\n1. Identify all fetch calls to old endpoints\n2. Replace with new /api/v1/ endpoints\n3. Add API key header to fetch calls\n4. Update field names in the response handling code\n\nExample transformation:\n\nOld code:\n```javascript\nfetch('/json/get_events.php')\n  .then(response => response.json())\n  .then(data => {\n    data.forEach(event => {\n      console.log(event.EventName, event.Startdate);\n    });\n  });\n```\n\nNew code:\n```javascript\nfetch('/api/v1/events.php', {\n  headers: {\n    'X-API-Key': 'your-api-key-here' // Store in a config file or environment variable\n  }\n})\n  .then(response => response.json())\n  .then(data => {\n    data.forEach(event => {\n      console.log(event.name, event.date); // Note the updated field names\n    });\n  });\n```\n\nCreate a central configuration file for storing the API key:\n```javascript\n// api-config.js\nconst API_CONFIG = {\n  key: 'your-api-key-here',\n  baseUrl: '/api/v1'\n};\n\n// Helper function for API calls\nasync function apiCall(endpoint, params = {}) {\n  const url = new URL(API_CONFIG.baseUrl + endpoint, window.location.origin);\n  \n  // Add query parameters\n  Object.keys(params).forEach(key => {\n    url.searchParams.append(key, params[key]);\n  });\n  \n  const response = await fetch(url, {\n    headers: {\n      'X-API-Key': API_CONFIG.key\n    }\n  });\n  \n  if (!response.ok) {\n    throw new Error(`API error: ${response.status}`);\n  }\n  \n  return response.json();\n}\n\n// Usage example:\n// apiCall('/events.php', { year: 2023 })\n//   .then(data => console.log(data))\n//   .catch(error => console.error(error));\n```",
      "testStrategy": "Test each updated fetch call to ensure it correctly retrieves data from the new API endpoints. Verify the response handling code correctly processes the standardized field names. Test error handling for API errors and network failures.",
      "priority": "medium",
      "dependencies": [
        8,
        9,
        10,
        11
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 15,
      "title": "Test and Verify Complete Migration",
      "description": "Conduct comprehensive testing of all API endpoints and frontend integration to ensure a successful migration.",
      "details": "1. Create a test plan covering all API endpoints and frontend pages\n2. Test each API endpoint individually:\n   - Test with valid and invalid parameters\n   - Test with and without API keys\n   - Verify response format matches OpenAPI specification\n   - Verify error handling for various scenarios\n3. Test frontend integration:\n   - Verify all pages load correctly with the new API\n   - Test user interactions that trigger API calls\n   - Verify data is displayed correctly with the new field names\n4. Performance testing:\n   - Compare response times between old and new endpoints\n   - Identify and address any performance issues\n5. Security testing:\n   - Verify API key validation works correctly\n   - Test for common security vulnerabilities\n6. Documentation verification:\n   - Ensure Swagger UI correctly documents all endpoints\n   - Verify examples in documentation work as expected\n7. Create a migration report documenting:\n   - Successful tests\n   - Any issues encountered and their resolutions\n   - Performance comparisons\n   - Recommendations for future improvements",
      "testStrategy": "Use a combination of manual testing and automated test scripts. Create a test matrix covering all endpoints with various parameter combinations. Document all test results and any issues encountered. Verify all success criteria from the PRD are met.",
      "priority": "high",
      "dependencies": [
        8,
        9,
        10,
        11,
        12,
        14
      ],
      "status": "pending",
      "subtasks": []
    },
    {
      "id": 16,
      "title": "Task #16: Design Comprehensive RESTful API Endpoints from DUV Schema",
      "description": "Parse the duv.sql schema file and design a complete set of RESTful API endpoints with appropriate HTTP methods, URL patterns, and parameter specifications that will serve both the new DUV frontend and external API consumers.",
      "details": "This task involves a thorough analysis of the duv.sql schema to create a well-structured RESTful API design:\n\n1. Schema Analysis:\n   - Parse the entire duv.sql file to identify all tables, relationships, and fields\n   - Document primary and foreign key relationships\n   - Identify data types and constraints for all fields\n   - Note any triggers, stored procedures, or views that may impact API design\n\n2. API Design Principles:\n   - Follow RESTful best practices (resource naming, HTTP methods, status codes)\n   - Use plural nouns for resource collections\n   - Implement consistent URL patterns (/resources, /resources/{id}, etc.)\n   - Design hierarchical relationships where appropriate (/resources/{id}/subresources)\n\n3. For Each Resource (Table):\n   - Define CRUD operations with appropriate HTTP methods:\n     * GET for retrieval (both collections and individual resources)\n     * POST for creation\n     * PUT/PATCH for updates\n     * DELETE for removal\n   - Document query parameters for filtering, sorting, pagination\n   - Specify path parameters for resource identification\n   - Define request body schemas for POST/PUT/PATCH operations\n\n4. Response Design:\n   - Create JSON response schemas for each endpoint\n   - Include pagination metadata for collection endpoints\n   - Define error response formats\n   - Document HTTP status codes for various scenarios\n\n5. Authentication/Authorization:\n   - Specify which endpoints require authentication\n   - Document any role-based access controls\n   - Define how API keys or tokens should be passed\n\n6. Documentation Format:\n   - Organize the API documentation in a structured format (OpenAPI/Swagger preferred)\n   - Include examples for requests and responses\n   - Document any rate limiting or usage constraints\n\n7. Special Considerations:\n   - Identify any complex business logic that might require custom endpoints\n   - Plan for versioning strategy\n   - Consider backward compatibility with existing systems\n   - Address any performance concerns for large datasets",
      "testStrategy": "The API design should be verified through the following steps:\n\n1. Documentation Review:\n   - Conduct a peer review of the API design documentation\n   - Verify that all tables from duv.sql have corresponding API endpoints\n   - Check that all required fields are properly represented in request/response schemas\n   - Ensure naming conventions are consistent throughout\n\n2. Schema Validation:\n   - Create a mapping document that shows how each database table and field maps to API endpoints and response objects\n   - Verify that all relationships in the database are properly reflected in the API design\n   - Confirm that all data types are appropriately represented in the API\n\n3. Frontend Requirements Validation:\n   - Review the new DUV frontend requirements to ensure all needed data operations are supported\n   - Create test scenarios that simulate typical frontend user flows\n   - Verify that pagination, filtering, and sorting capabilities meet frontend needs\n\n4. External API Consumer Validation:\n   - Review any known external API consumer requirements\n   - Ensure the API design supports all required use cases\n   - Verify that documentation is clear enough for external developers\n\n5. Prototype Testing:\n   - Create mock responses for key endpoints\n   - Test these with frontend developers to verify they meet requirements\n   - Adjust designs based on feedback\n\n6. Security Review:\n   - Verify that authentication and authorization mechanisms are appropriate\n   - Ensure sensitive data is properly protected\n   - Check that appropriate validation rules are defined for inputs\n\n7. Performance Consideration:\n   - Identify potential performance bottlenecks in the API design\n   - Suggest optimizations for endpoints that might return large datasets\n   - Consider caching strategies where appropriate\n\n8. Final Approval:\n   - Present the API design to stakeholders for final approval\n   - Document any feedback or requested changes\n   - Finalize the API specification document for implementation",
      "status": "pending",
      "dependencies": [],
      "priority": "high",
      "subtasks": [
        {
          "id": 1,
          "title": "Parse and analyze duv.sql schema structure",
          "description": "Extract and document all tables, relationships, fields, data types, constraints, and database objects from the duv.sql schema file.",
          "dependencies": [],
          "details": "Write a script or use a database tool to parse the duv.sql file. Create a comprehensive document that lists all tables with their columns, data types, primary/foreign keys, and constraints. Identify and document any triggers, stored procedures, or views. Organize the information in a structured format that can be easily referenced during API design. Generate an entity-relationship diagram to visualize the database structure.",
          "status": "done",
          "testStrategy": "Verify the completeness of the schema analysis by comparing it with the actual database structure. Ensure all tables, columns, relationships, and constraints are correctly identified."
        },
        {
          "id": 2,
          "title": "Group database entities into logical API resources",
          "description": "Organize database tables and views into logical API resources, identifying resource hierarchies and relationships.",
          "dependencies": [
            1
          ],
          "details": "Based on the schema analysis, group related tables into logical API resources. Determine which database entities should be exposed as top-level resources and which should be nested. Define resource naming conventions following RESTful best practices (plural nouns). Map database relationships to resource hierarchies. Create a document that outlines each resource, its corresponding database entities, and its relationships to other resources.",
          "status": "done",
          "testStrategy": "Review the resource grouping with stakeholders to ensure it meets both technical requirements and business needs. Verify that all necessary database entities are represented in the API resource structure."
        },
        {
          "id": 3,
          "title": "Design core CRUD endpoints for each resource",
          "description": "Define the standard CRUD operations for each identified resource with appropriate HTTP methods, URL patterns, and parameter specifications.",
          "dependencies": [
            2
          ],
          "details": "For each resource identified in the previous step, design standard CRUD endpoints: GET /resources (list), GET /resources/{id} (retrieve), POST /resources (create), PUT/PATCH /resources/{id} (update), and DELETE /resources/{id} (delete). Document URL patterns, path parameters, query parameters for filtering/sorting/pagination, and request body schemas for POST/PUT/PATCH operations. Specify expected HTTP status codes for success and error scenarios.\n<info added on 2025-05-18T19:14:30.582Z>\nFor each resource identified in the previous step, design standard CRUD endpoints: GET /resources (list), GET /resources/{id} (retrieve), POST /resources (create), PUT/PATCH /resources/{id} (update), and DELETE /resources/{id} (delete). Document URL patterns, path parameters, query parameters for filtering/sorting/pagination, and request body schemas for POST/PUT/PATCH operations. Specify expected HTTP status codes for success and error scenarios.\n\nPhase 1 will focus on implementing read-only endpoints for the core resources. The following endpoints have been defined for the initial implementation:\n\n1. GET /events\n   - Purpose: Retrieve a list of events\n   - Query parameter: `year` (integer, optional, default to current year)\n   - Response: 200 OK with array of Event objects\n   - Error codes: 400 Bad Request (invalid parameters), 500 Internal Server Error\n\n2. GET /events/{eventId}\n   - Purpose: Retrieve a specific event by ID\n   - Path parameter: `eventId` (string, required)\n   - Response: 200 OK with Event object\n   - Error codes: 404 Not Found (invalid eventId), 500 Internal Server Error\n\n3. GET /results\n   - Purpose: Retrieve results filtered by event or runner\n   - Query parameters: \n     * `eventId` (string, optional)\n     * `runnerId` (string, optional)\n   - Constraints: At least one of `eventId` or `runnerId` must be provided\n   - Response: 200 OK with array of Result objects\n   - Error codes: 400 Bad Request (missing required parameters), 404 Not Found (invalid IDs), 500 Internal Server Error\n\n4. GET /runners/{runnerId}\n   - Purpose: Retrieve a specific runner by ID\n   - Path parameter: `runnerId` (string, required)\n   - Response: 200 OK with Runner object\n   - Error codes: 404 Not Found (invalid runnerId), 500 Internal Server Error\n\nThese endpoints will serve as the foundation for the API. Future phases will expand to include write operations (POST, PUT/PATCH, DELETE) for each resource.\n</info added on 2025-05-18T19:14:30.582Z>",
          "status": "done",
          "testStrategy": "Create sample requests and responses for each endpoint to validate the design. Ensure the endpoints follow RESTful conventions and cover all necessary CRUD operations."
        },
        {
          "id": 4,
          "title": "Design specialized non-CRUD endpoints",
          "description": "Identify and design specialized endpoints for complex operations that don't fit the standard CRUD pattern.",
          "dependencies": [
            3
          ],
          "details": "Review the schema and business requirements to identify operations that don't fit the standard CRUD pattern (e.g., actions, calculations, reports, bulk operations). Design appropriate endpoints for these operations, following RESTful principles where possible. Document the HTTP methods, URL patterns, request parameters, and response formats for each specialized endpoint. Explain the rationale behind each non-standard endpoint.\n<info added on 2025-05-18T19:38:38.685Z>\nReview the schema and business requirements to identify operations that don't fit the standard CRUD pattern (e.g., actions, calculations, reports, bulk operations). Design appropriate endpoints for these operations, following RESTful principles where possible. Document the HTTP methods, URL patterns, request parameters, and response formats for each specialized endpoint. Explain the rationale behind each non-standard endpoint.\n\nBased on the DUV schema analysis, the following specialized non-CRUD endpoints have been identified:\n\n1. Search Endpoints:\n   - GET /search/events\n     • Query param: `query` (string, required) — full-text search on eventName and city\n     • Response: 200 → array of `Event`\n     • Rationale: enables autocomplete and event lookup by keyword\n\n   - GET /search/runners\n     • Query param: `query` (string, required) — search on firstName and lastName\n     • Response: 200 → array of `Runner`\n     • Rationale: supports runner lookup and search functionality in the UI\n\n2. Filtered View Endpoints:\n   - GET /events/calendar\n     • Query params:\n       ◦ `year` (integer, required)\n       ◦ `distance` (string, optional) — e.g. '50km', '100km'\n     • Response: 200 → array of `Event`\n     • Rationale: returns a list of events organized for calendar display, filtered by year and optionally distance\n\n3. Specialized Report Endpoints:\n   - GET /results/abroad\n     • Query params:\n       ◦ `nationality` (string, required)\n       ◦ `year` (integer, optional)\n     • Response: 200 → array of `Result`\n     • Rationale: lists performances in races outside a runner's home country for border-crossing statistics\n\nThese specialized endpoints follow RESTful principles while addressing complex business requirements that go beyond basic CRUD operations. They provide targeted functionality for search, filtered views, and specialized reports that will enhance the application's usability.\n</info added on 2025-05-18T19:38:38.685Z>",
          "status": "done",
          "testStrategy": "Review the specialized endpoints with stakeholders to ensure they address complex business requirements. Validate that the design maintains RESTful principles where appropriate."
        },
        {
          "id": 5,
          "title": "Define response schemas and error handling",
          "description": "Create detailed JSON response schemas for all endpoints and standardize error response formats.",
          "dependencies": [
            3,
            4
          ],
          "details": "Define JSON response schemas for each endpoint, including field names, data types, and example values. Create a consistent structure for collection responses that includes pagination metadata. Standardize error response formats with appropriate HTTP status codes, error codes, error messages, and additional details. Document how validation errors, authentication errors, authorization errors, and server errors will be represented. Include examples of successful and error responses for each endpoint.",
          "status": "in-progress",
          "testStrategy": "Validate that response schemas accurately represent the data from the underlying database schema. Ensure error responses provide sufficient information for troubleshooting while maintaining security."
        },
        {
          "id": 6,
          "title": "Specify authentication and authorization requirements",
          "description": "Define authentication mechanisms and authorization rules for each endpoint.",
          "dependencies": [
            3,
            4
          ],
          "details": "Specify the authentication mechanism to be used (e.g., API keys, JWT tokens, OAuth). Document how authentication credentials should be passed in requests. For each endpoint, define authorization requirements: which user roles can access it, what operations are permitted for each role, and any resource-level permissions. Create a matrix mapping endpoints to required permissions. Document any rate limiting or usage constraints that will be applied.",
          "status": "pending",
          "testStrategy": "Review the authentication and authorization design with security stakeholders. Verify that the design follows security best practices and meets compliance requirements."
        },
        {
          "id": 7,
          "title": "Create OpenAPI/Swagger documentation",
          "description": "Compile all API design elements into a comprehensive OpenAPI/Swagger specification document.",
          "dependencies": [
            5,
            6
          ],
          "details": "Create an OpenAPI/Swagger specification document that includes all endpoints, parameters, request bodies, response schemas, authentication requirements, and examples. Organize the documentation in a logical structure, grouping related endpoints. Include descriptive information about each resource and operation. Add examples for requests and responses. Document any API versioning strategy and backward compatibility considerations. Ensure the specification can be imported into API documentation tools.",
          "status": "done",
          "testStrategy": "Validate the OpenAPI/Swagger document against the OpenAPI specification. Test importing it into documentation tools like Swagger UI to ensure it renders correctly. Review the documentation with potential API consumers to ensure clarity and completeness."
        },
        {
          "id": 8,
          "title": "Document reusable parameters",
          "description": "Extract every parameter used by our Phase 1 endpoints and define them in components.parameters with name, in, required flag, schema type, description, and best-practice settings (style, explode) for OpenAPI 3.1.1. Then reference them in each path operation.",
          "details": "",
          "status": "done",
          "dependencies": [],
          "parentTaskId": 16
        }
      ]
    },
    {
      "id": 17,
      "title": "Task #17: Implement Event-Race Hierarchy in API Structure",
      "description": "Restructure the API to introduce a hierarchical relationship between events and races, renaming the current `/events` resource to `/races` and creating appropriate nested resources to reflect the parent-child relationship.",
      "details": "This task involves a significant restructuring of the API to better model the domain:\n\n1. Rename the current `/events` resource to `/races` in all API endpoints\n2. Design new endpoints to represent the hierarchical relationship:\n   - `/events` - to manage top-level event entities\n   - `/events/{eventId}/races` - to manage races within a specific event\n   - `/races/{raceId}` - for direct access to specific races\n3. Define a comprehensive Race schema that includes:\n   - Distance (e.g., 5K, 10K, marathon)\n   - Category (e.g., adult, youth, elite)\n   - Start time\n   - Course information\n   - Any race-specific rules or requirements\n4. Update the API specification document to reflect these changes\n5. Modify existing endpoints to maintain backward compatibility where possible\n6. Update database schema to support the new hierarchy\n7. Implement data migration scripts to convert existing event data to the new structure\n8. Update any backend services that interact with these endpoints\n9. Coordinate with frontend developers to ensure they're aware of the upcoming changes\n\nConsider implementing a versioning strategy (e.g., `/v2/events`) to maintain backward compatibility during the transition period. Document any breaking changes clearly for API consumers.",
      "testStrategy": "To verify successful implementation of the event-race hierarchy:\n\n1. Unit Testing:\n   - Write comprehensive unit tests for all new and modified endpoints\n   - Verify proper validation of race properties (distance, category)\n   - Test error handling for invalid event-race relationships\n\n2. Integration Testing:\n   - Test the complete flow of creating events and associated races\n   - Verify that races are properly associated with their parent events\n   - Test retrieval of races both through the event hierarchy and directly\n\n3. Migration Verification:\n   - Create test cases that verify all existing data has been properly migrated\n   - Compare record counts before and after migration\n   - Verify sample records maintain all their original data in the new structure\n\n4. API Contract Testing:\n   - Use tools like Postman or Pact to verify the API conforms to the updated specification\n   - Test all CRUD operations on both events and races\n\n5. Backward Compatibility:\n   - If maintaining backward compatibility, test that old API calls still function correctly\n   - Verify deprecation warnings are properly returned if applicable\n\n6. Performance Testing:\n   - Benchmark the performance of nested queries (e.g., retrieving all races for an event)\n   - Compare with previous implementation to ensure no significant performance degradation\n\n7. Documentation Verification:\n   - Ensure API documentation accurately reflects the new structure\n   - Verify examples in documentation work as expected",
      "status": "pending",
      "dependencies": [],
      "priority": "medium",
      "subtasks": []
    }
  ]
}