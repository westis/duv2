# Task ID: 16
# Title: Task #16: Design Comprehensive RESTful API Endpoints from DUV Schema
# Status: pending
# Dependencies: None
# Priority: high
# Description: Parse the duv.sql schema file and design a complete set of RESTful API endpoints with appropriate HTTP methods, URL patterns, and parameter specifications that will serve both the new DUV frontend and external API consumers.
# Details:
This task involves a thorough analysis of the duv.sql schema to create a well-structured RESTful API design:

1. Schema Analysis:
   - Parse the entire duv.sql file to identify all tables, relationships, and fields
   - Document primary and foreign key relationships
   - Identify data types and constraints for all fields
   - Note any triggers, stored procedures, or views that may impact API design

2. API Design Principles:
   - Follow RESTful best practices (resource naming, HTTP methods, status codes)
   - Use plural nouns for resource collections
   - Implement consistent URL patterns (/resources, /resources/{id}, etc.)
   - Design hierarchical relationships where appropriate (/resources/{id}/subresources)

3. For Each Resource (Table):
   - Define CRUD operations with appropriate HTTP methods:
     * GET for retrieval (both collections and individual resources)
     * POST for creation
     * PUT/PATCH for updates
     * DELETE for removal
   - Document query parameters for filtering, sorting, pagination
   - Specify path parameters for resource identification
   - Define request body schemas for POST/PUT/PATCH operations

4. Response Design:
   - Create JSON response schemas for each endpoint
   - Include pagination metadata for collection endpoints
   - Define error response formats
   - Document HTTP status codes for various scenarios

5. Authentication/Authorization:
   - Specify which endpoints require authentication
   - Document any role-based access controls
   - Define how API keys or tokens should be passed

6. Documentation Format:
   - Organize the API documentation in a structured format (OpenAPI/Swagger preferred)
   - Include examples for requests and responses
   - Document any rate limiting or usage constraints

7. Special Considerations:
   - Identify any complex business logic that might require custom endpoints
   - Plan for versioning strategy
   - Consider backward compatibility with existing systems
   - Address any performance concerns for large datasets

# Test Strategy:
The API design should be verified through the following steps:

1. Documentation Review:
   - Conduct a peer review of the API design documentation
   - Verify that all tables from duv.sql have corresponding API endpoints
   - Check that all required fields are properly represented in request/response schemas
   - Ensure naming conventions are consistent throughout

2. Schema Validation:
   - Create a mapping document that shows how each database table and field maps to API endpoints and response objects
   - Verify that all relationships in the database are properly reflected in the API design
   - Confirm that all data types are appropriately represented in the API

3. Frontend Requirements Validation:
   - Review the new DUV frontend requirements to ensure all needed data operations are supported
   - Create test scenarios that simulate typical frontend user flows
   - Verify that pagination, filtering, and sorting capabilities meet frontend needs

4. External API Consumer Validation:
   - Review any known external API consumer requirements
   - Ensure the API design supports all required use cases
   - Verify that documentation is clear enough for external developers

5. Prototype Testing:
   - Create mock responses for key endpoints
   - Test these with frontend developers to verify they meet requirements
   - Adjust designs based on feedback

6. Security Review:
   - Verify that authentication and authorization mechanisms are appropriate
   - Ensure sensitive data is properly protected
   - Check that appropriate validation rules are defined for inputs

7. Performance Consideration:
   - Identify potential performance bottlenecks in the API design
   - Suggest optimizations for endpoints that might return large datasets
   - Consider caching strategies where appropriate

8. Final Approval:
   - Present the API design to stakeholders for final approval
   - Document any feedback or requested changes
   - Finalize the API specification document for implementation

# Subtasks:
## 1. Parse and analyze duv.sql schema structure [done]
### Dependencies: None
### Description: Extract and document all tables, relationships, fields, data types, constraints, and database objects from the duv.sql schema file.
### Details:
Write a script or use a database tool to parse the duv.sql file. Create a comprehensive document that lists all tables with their columns, data types, primary/foreign keys, and constraints. Identify and document any triggers, stored procedures, or views. Organize the information in a structured format that can be easily referenced during API design. Generate an entity-relationship diagram to visualize the database structure.

## 2. Group database entities into logical API resources [done]
### Dependencies: 16.1
### Description: Organize database tables and views into logical API resources, identifying resource hierarchies and relationships.
### Details:
Based on the schema analysis, group related tables into logical API resources. Determine which database entities should be exposed as top-level resources and which should be nested. Define resource naming conventions following RESTful best practices (plural nouns). Map database relationships to resource hierarchies. Create a document that outlines each resource, its corresponding database entities, and its relationships to other resources.

## 3. Design core CRUD endpoints for each resource [done]
### Dependencies: 16.2
### Description: Define the standard CRUD operations for each identified resource with appropriate HTTP methods, URL patterns, and parameter specifications.
### Details:
For each resource identified in the previous step, design standard CRUD endpoints: GET /resources (list), GET /resources/{id} (retrieve), POST /resources (create), PUT/PATCH /resources/{id} (update), and DELETE /resources/{id} (delete). Document URL patterns, path parameters, query parameters for filtering/sorting/pagination, and request body schemas for POST/PUT/PATCH operations. Specify expected HTTP status codes for success and error scenarios.
<info added on 2025-05-18T19:14:30.582Z>
For each resource identified in the previous step, design standard CRUD endpoints: GET /resources (list), GET /resources/{id} (retrieve), POST /resources (create), PUT/PATCH /resources/{id} (update), and DELETE /resources/{id} (delete). Document URL patterns, path parameters, query parameters for filtering/sorting/pagination, and request body schemas for POST/PUT/PATCH operations. Specify expected HTTP status codes for success and error scenarios.

Phase 1 will focus on implementing read-only endpoints for the core resources. The following endpoints have been defined for the initial implementation:

1. GET /events
   - Purpose: Retrieve a list of events
   - Query parameter: `year` (integer, optional, default to current year)
   - Response: 200 OK with array of Event objects
   - Error codes: 400 Bad Request (invalid parameters), 500 Internal Server Error

2. GET /events/{eventId}
   - Purpose: Retrieve a specific event by ID
   - Path parameter: `eventId` (string, required)
   - Response: 200 OK with Event object
   - Error codes: 404 Not Found (invalid eventId), 500 Internal Server Error

3. GET /results
   - Purpose: Retrieve results filtered by event or runner
   - Query parameters: 
     * `eventId` (string, optional)
     * `runnerId` (string, optional)
   - Constraints: At least one of `eventId` or `runnerId` must be provided
   - Response: 200 OK with array of Result objects
   - Error codes: 400 Bad Request (missing required parameters), 404 Not Found (invalid IDs), 500 Internal Server Error

4. GET /runners/{runnerId}
   - Purpose: Retrieve a specific runner by ID
   - Path parameter: `runnerId` (string, required)
   - Response: 200 OK with Runner object
   - Error codes: 404 Not Found (invalid runnerId), 500 Internal Server Error

These endpoints will serve as the foundation for the API. Future phases will expand to include write operations (POST, PUT/PATCH, DELETE) for each resource.
</info added on 2025-05-18T19:14:30.582Z>

## 4. Design specialized non-CRUD endpoints [done]
### Dependencies: 16.3
### Description: Identify and design specialized endpoints for complex operations that don't fit the standard CRUD pattern.
### Details:
Review the schema and business requirements to identify operations that don't fit the standard CRUD pattern (e.g., actions, calculations, reports, bulk operations). Design appropriate endpoints for these operations, following RESTful principles where possible. Document the HTTP methods, URL patterns, request parameters, and response formats for each specialized endpoint. Explain the rationale behind each non-standard endpoint.
<info added on 2025-05-18T19:38:38.685Z>
Review the schema and business requirements to identify operations that don't fit the standard CRUD pattern (e.g., actions, calculations, reports, bulk operations). Design appropriate endpoints for these operations, following RESTful principles where possible. Document the HTTP methods, URL patterns, request parameters, and response formats for each specialized endpoint. Explain the rationale behind each non-standard endpoint.

Based on the DUV schema analysis, the following specialized non-CRUD endpoints have been identified:

1. Search Endpoints:
   - GET /search/events
     • Query param: `query` (string, required) — full-text search on eventName and city
     • Response: 200 → array of `Event`
     • Rationale: enables autocomplete and event lookup by keyword

   - GET /search/runners
     • Query param: `query` (string, required) — search on firstName and lastName
     • Response: 200 → array of `Runner`
     • Rationale: supports runner lookup and search functionality in the UI

2. Filtered View Endpoints:
   - GET /events/calendar
     • Query params:
       ◦ `year` (integer, required)
       ◦ `distance` (string, optional) — e.g. '50km', '100km'
     • Response: 200 → array of `Event`
     • Rationale: returns a list of events organized for calendar display, filtered by year and optionally distance

3. Specialized Report Endpoints:
   - GET /results/abroad
     • Query params:
       ◦ `nationality` (string, required)
       ◦ `year` (integer, optional)
     • Response: 200 → array of `Result`
     • Rationale: lists performances in races outside a runner's home country for border-crossing statistics

These specialized endpoints follow RESTful principles while addressing complex business requirements that go beyond basic CRUD operations. They provide targeted functionality for search, filtered views, and specialized reports that will enhance the application's usability.
</info added on 2025-05-18T19:38:38.685Z>

## 5. Define response schemas and error handling [done]
### Dependencies: 16.3, 16.4
### Description: Create detailed JSON response schemas for all endpoints and standardize error response formats.
### Details:
Define JSON response schemas for each endpoint, including field names, data types, and example values. Create a consistent structure for collection responses that includes pagination metadata. Standardize error response formats with appropriate HTTP status codes, error codes, error messages, and additional details. Document how validation errors, authentication errors, authorization errors, and server errors will be represented. Include examples of successful and error responses for each endpoint.

## 6. Specify authentication and authorization requirements [done]
### Dependencies: 16.3, 16.4
### Description: Define authentication mechanisms and authorization rules for each endpoint.
### Details:
Specify the authentication mechanism to be used (e.g., API keys, JWT tokens, OAuth). Document how authentication credentials should be passed in requests. For each endpoint, define authorization requirements: which user roles can access it, what operations are permitted for each role, and any resource-level permissions. Create a matrix mapping endpoints to required permissions. Document any rate limiting or usage constraints that will be applied.

## 7. Create OpenAPI/Swagger documentation [done]
### Dependencies: 16.5, 16.6
### Description: Compile all API design elements into a comprehensive OpenAPI/Swagger specification document.
### Details:
Create an OpenAPI/Swagger specification document that includes all endpoints, parameters, request bodies, response schemas, authentication requirements, and examples. Organize the documentation in a logical structure, grouping related endpoints. Include descriptive information about each resource and operation. Add examples for requests and responses. Document any API versioning strategy and backward compatibility considerations. Ensure the specification can be imported into API documentation tools.

## 8. Document reusable parameters [done]
### Dependencies: None
### Description: Extract every parameter used by our Phase 1 endpoints and define them in components.parameters with name, in, required flag, schema type, description, and best-practice settings (style, explode) for OpenAPI 3.1.1. Then reference them in each path operation.
### Details:


